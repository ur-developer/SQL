CREATE TABLE DEPT_TCL
AS SELECT * FROM DEPT;

SELECT * FROM  DEPT_TCL;

INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', SEUOL);
UPDATE DEPT_TCL SET LOC = 'BUSAN' WHERE DEPTNO = 40;
DELETE FROM DEPT_TCL WHERE DNAME = 'RESEARCH';

SELECT * FROM DEPT_TCL;

ROLLBACK;

SELECT * FROM DEPT_TCL;

COMMIT;

SELECT * FROM DEPT_TCL;

DROP TABLE DEPT_TCL;

CREATE TABLE EMP_DDL(
EMPNO NUMBER(4),
ENAME VARCHAR2(10),
JOB VARCHAR2(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7, 2),
COMM NUMBER(7, 2),
DEPTNO NUMBER(2)
);

SELECT  * FROM EMP_DDL;

--다른 테이블의 일부를 복사하여 테이블 생성하기
CREATE TABLE EMP_DDL_30
AS SELECT * FROM EMP
WHERE DEPTNO = 30;

SELECT * FROM EMP_DDL_30;

SELECT *
FROM HR.EMPLOYEES;

-- 테이블명 MEMBER(USERID, PASSWORD, EMAIL)
-- HR.EMAIL -> USERID 이름 변경              sking
-- PASSWORD 컬럼은 USERID와 동일한 값           sking
-- EMAIL 컬럼 기존 EMAIL @GALAPAGOS.OR sking@galapagos.org
-- 문자열 결합 : ||

CREATE TABLE MEMBER
AS 
SELECT EMAIL USERID, EMAIL PASSWORD, LOWER(EMAIL) || '@galapagos.org' email
FROM HR.EMPLOYEES;

SELECT * FROM MEMBER;

UPDATE MEMBER
SET PASSWORD = LOWER(PASSWORD),
    USERID = LOWER(USERID);
    
-- ALTER 명령어 EMP 테이블을 복사하여 EMP_ALTER 테이블 생성하기
CREATE TABLE EMP_ALTER
AS SELECT * FROM EMP;

SELECT * FROM EMP_ALTER;

--테이블에 열 추가하는 ADD, ALTER 멸령어로 HP 열 추가하기
ALTER TABLE EMP_ALTER
ADD HP VARCHAR2(20);

-- 열 이름을 변경하는 RENAME , ALTER 명령어로 HP 열 이름을 TEL로 변경하기
ALTER TABLE EMP_ALTER
RENAME COLUMN HP TO TELL;

SELECT * FROM EMP_ALTER;

-- 열의 자료형을 변경하는 MODIFY, ALTER 명령어로 EMPNO 열 길이 변경하기
ALTER TABLE EMP_ALTER
MODIFY EMPNO NUMBER(3); -- 기존 컬럼에 Data 있는경우 길이는 늘어나는 경우만 허용, 줄어드는경우 불가 , Data가 없는경우 -> 항상 가능

-- 특정 열을 삭제할 때 사용하는 DROP ,ALTER 명령어로 TEL열 삭제하기

ALTER TABLE EMP_ALTER
DROP COLUMN TELL;

SELECT * FROM EMP_ALTER;

-- 테이블 이름 변경하기 RENAME
RENAME EMP_ALTER TO EMP_RENAME;

SELECT * FROM EMP_RENAME;

--테이블의 데이터를 삭제하는 TRUNCATE(DDL 롤백(ROLLBACK) 불가) , EMP_RENAME 테이블의 전체 데이터 삭제하기
TRUNCATE TABLE EMP_RENAME;

SELECT * FROM EMP_RENAME;

--테이블을 삭제하는 DROP
DROP TABLE EMP_RENAME;

SELECT ROWID, E.*
FROM EMP_ALTER E;

-- 테이블을 생성하며 제약조건 지정 , 테이블을 생성할 때 NOT NULL 설정하기

CREATE TABLE TABLE_NOTNULL(
LOGIN_ID VARCHAR2(20) NOT NULL,
LOGIN_PWD VARCHAR2(20) NOT NULL,
TEL VARCHAR2(20)
);

-- 제약 조건이 NOT NULL인 열에 NULL 값 넣어보기
INSERT INTO TABLE_NOTNULL(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', NULL, '1234');

-- NOT NULL 제약 조건이 지정된 열 데이터를 NULL 값으로 업데이트하기
UPDATE TABLE_NOTNULL
SET LOGIN PWD = NULL
WHERE LOGIN_ID = 'TEST_ID_01';

-- 제약 조건 살펴보기(SCOTT 계정)
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS;

-- 테이블을 생성할 때 제약 조건에 이름 지정하기

CREATE TABLE TABLE_NOTNULL2(
LOGIN_ID VARCHAR2(20) CONSTRAINT TBLNN2_LGNID_NN NOT NULL,
LOGIN_PWD VARCHAR2(20) CONSTRAINT  TBLNN2_LGNPW_NN NOT NULL,
TEL VARCHAR2(20)
);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE
FROM USER CONSTRAINT
WHERE TABLE_NAME = 'TABLE_NOTNULL2';

-- 이미 생성한 테이블에 제약 조건 지정
ALTER TABLE TABLE_NOTNULL
MODIFY(TEL NOT NULL);

SELECT * FROM TABLE_NOTNULL;

UPDATE TABLE_NOTNULL
SET TEL = '010-1234-5678'
WHERE LOGIN_ID = 'TEST_ID_01';

-- 이미 생성한 테이블에 제약조건 지정, 생성한 테이블에 제약 조건 이름 직접 지정해서 추가하기
ALTER TABLE TABLE_NOTNULL2 
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

SELECT * FROM TABLE_NOTNULL2;

-- 이미 생성한 테이블에 제약 조건 지정, 생성한 제약 조근의 이름 변경하기
ALTER TABLE TABLE_NOTNULL2
RENAME CONSTRAINT TBLNN_TEL_NN TO TBLNN2_TEL_NN;

-- 제약 조건 삭제하기
ALTER TABLE TABLE_NOTNULL2
DROP CONSTRAINT 

-- UNIQUE 제약 조건 지정하기(테이블 생성할 때)
DROP TABLE TABLE_UNIQUE;
CREATE TABLE TABLE_UNIQUE(
	LOGIN_ID  VARCHAR2(20) UNIQUE,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL       VARCHAR2(20) 
);

-- 제약 조건 확인 , USER_CONSTRAINTS 데이터 사전 뷰로 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'TABLE_UNIQUE';

-- 중복을 허락하지 않는 UNIQUE , TABLE_UNIQUE 테이블에 데이터 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_02', 'PWD01', '010-1234-5678');

SELECT * FROM TABLE_UNIQUE;

--UNIQUE 제약 조건이 지정 된 열에 NULL 값 입력하기
INSERT INTO TABLE_UNIQUE(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD01', '010-2345-6789');

CREATE TABLE TABLE_UNIQUE(
	LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLUNIQ_LOGINID_U UNIQUE,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL       VARCHAR2(20) 
);


-- 테이블을 생성할 때 특정열에 PRIMARY KEY 설정하기
DROP TABLE TABLE_PK;
CREATE TABLE TABLE_PK(
	LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLPK2_LGNID_PK PRIMARY KEY,
	LOGIN_PWD VARCHAR2(20) NOT NULL,
	TEL 	  VARCHAR2(20)
);

SELECT * FROM TABLE_PK;

INSERT  INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');

INSERT  INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID_01', 'PWD01', '010-1234-5678');


INSERT  INTO TABLE_PK(LOGIN_ID, LOGIN_PWD, TEL)
VALUES(NULL, 'PWD02', '010-1234-5678');

-- FOREIGN KEY가 참조하는 열에 존재하지 않는 데이터 입력하기
INSERT INTO EMP(EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(9999, '홍길동', 'CLERK', '7788', TO_DATE('2017/04/30', 'YYYY/MM/DD'),
	1200, NULL, 50);

-- FOREIGN KEY 지정하기
-- 컬럼 레벨에서 PK선언
DROP TABLE DEPT_FK;
CREATE TABLE DEPT_FK( -- 부모 테이블
  DEPTNO NUMBER(2) CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY,
  DNAME VARCHAR2(14),
  LOC   VARCHAR2(13)
);

-- 테이블 레벨에서 PK선언
DROP TABLE DEPT_FK;
CREATE TABLE DEPT_FK(
  DEPTNO NUMBER(2) ,
  DNAME  VARCHAR2(14),
  LOC    VARCHAR2(13),
  CONSTRAINT DEPTFK_DEPTNO_PK PRIMARY KEY(DEPTNO)
);


--EMP_FK 테이블 생성하기
DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
EMPNO  NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
ENAME  VARCHAR2(10),
JOB    VARCHAR2(9),
MGR	   NUMBER(4),
HIREDATE DATE,
SAL    NUMBER(7, 2),
COMM   NUMBER(7, 2),
DEPTNO NUMBER(2) 
CONSTRAINT EMPFK_DEPTNO_FK FOREIGN KEY(DEPTNO)
	REFERENCES DEPT_FK(DEPTNO)


-- 테이블 레벨 PK, FK설정 
DROP TABLE EMP_FK;
CREATE TABLE EMP_FK(
EMPNO  NUMBER(4) CONSTRAINT EMPFK_EMPNO_PK PRIMARY KEY,
ENAME  VARCHAR2(10),
JOB    VARCHAR2(9),
MGR	   NUMBER(4),
HIREDATE DATE,
SAL    NUMBER(7, 2),
COMM   NUMBER(7, 2),
DEPTNO NUMBER(2) 
CONSTRAINT EMPFK_EMPNO_PK PRIMARY(EMPNO),
CONSTRAINT EMPFK_DEPTNO_FK FOREIGN KEY(DEPTNO)
	REFERENCES DEPT_FK(DEPTNO) ON DELETE SET NULL;
);

SELECT * FROM EMP_FK;

-- DEPT_FK에 데이터 삽입하기 (Parent)
INSERT INTO DEPT_FK
VALUES(10, 'TEST_NAME', 'TEST_LOC');

-- EMP_FK 테이블에 데이터삽입 (Child)
INSERT INTO EMP_FK
VALUES(9999, 'TEST_NAME', 'TEST_JOB', NULL, TO_DATE('2001/01/01', 'YYYY/MM/DD'), 3000, NULL, 10);

SELECT * FROM DEPT_FK;
SELECT * FROM EMP_FK;

-- 테이블을 생성할 때 CHECK 제약 조건 설정하기
DROP TABLE TABLE_CHECK;
CREATE TABLE TABLE_CHECK(
	LOGIN_ID  VARCHAR2(20) CONSTRAINT TBLCK_LGNID_PK PRIMARY KEY,
	LOGIN_PWD VARCHAR2(20) CONSTRAINT TBLCK_LGNPW_CK
							CHECK(LENGTH(LOGIN_PWD) > 3),
	TEL       VARCHAR2(20)
);

-- 제약조건에 맞지 않는 예
INSERT INTO TABLE_CHECK
VALUES('TEST_ID', '123', '010-1234-5678');

-- ORA-02290: check constraint (SCOTT.TBLCK_LGNPW_CK) violated

-- 제약 조건에 맞는 예
INSERT INTO TABLE_CHECK
VALUES('TEST_ID', '1234', '010-1234-5678');

SELECT * FROM TABLE_CHECK;

-- 제약 조건 확인하기
SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME LIKE 'TABLE_CHECK';

-- 테이블을 생성할 때 DEFAULT 제약 조건 설정하기
DROP TABLE TABLE_DEFAULT;
CREATE TABLE TABLE_DEFAULT(
	LOGIN_ID   VARCHAR2(20) CONSTRAINT TBLCK2_LGNID_PK PRIMARY KEY,
	LOGIN_PWD  VARCHAR2(20) DEFAULT '1234',
	TEL        VARCHAR2(20),
	REG_DATE DATE DEFAULT SYSDATE,
	UPDATE_DATE DATE DEFAULT SYSDATE	
	);

-- DAFAULT로 지정한 기본값이 입력되는 INSERT문 확인하기
INSERT INTO TABLE_DEFAULT(LOGIN_ID, LOGIN_PWD, TEL)
VALUES('TEST_ID', NULL, '010-1234-5678');

INSERT INTO TABLE_DEFAULT(LOGIN_ID, TEL)
VALUES('TEST_ID2', '010-1234-5678');

SELECT * FROM TABLE_DEFAULT;

--SCOTT 계정이 소유한 인덱스 컬럼 정보 알아보기(SCOTT 계정일 때)
SELECT * 
FROM USER_IND_COLUMNS;

-- EMP 테이블의 SAL 열에 인덱스를 생성하기
DROP INDEX IDX_EMP_SAL;
CREATE INDEX IDX_EMP_SAL
		ON EMP(SAL);
		
-- 생성된 인덱스 살펴보기(USER_IND_COLUMNS 사용)	
SELECT *
FROM USER_IND_COLUMNS;

-- VIEW 생성하기
CREATE VIEW VW_EMP20
AS (SELECT EMPNO, ENAME, JOB, DEPTNO
	FROM EMP
	WHERE DEPTNO = 20);

SELECT ROWNUM, E.* 
FROM EMP E
ORDER BY SAL;

-- 인라인 뷰를 이용한 TOP-N SQL 문
-- ORDER BY 결과에 ROWNUM을 붙이면 순위(등수)로 해석 가능
SELECT ROWNUM, E.* 
FROM (SELECT *
	  FROM EMP E 
	  ORDER BY SAL DESC) E;
 --WHERE ROWNUM <= 3;

CREATE VIEW EMP_SAL_RANK
AS
	SELECT ROW_NUMBER() OVER(ORDER BY SAL DESC) SEQ, E.*
	FROM EMP E;
	
SELECT * FROM EMP_SAL_RANK
--WHERE SEQ BETWEEN 3 AND 5;
WHERE SEQ > 5;`

-- SAL로 내림차순
-- SEQ, EMPNO, EMPNAME, DEPTNO, DNAME을 가지는 뷰

CREATE OR REPLACE VIEW EMP_DETAIL
AS
	SELECT 
	ROW_NUMBER() OVER(ORDER BY SAL DESC) SEQ,
	E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME
	FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO);

SELECT * FROM EMP_DETAIL
WHERE SEQ BETWEEN 5 AND 10;

-- 시퀀스 생성 실습준비
-- 제약 조건은 복사되지 않음.
DROP TABLE DEPT_SEQUENCE;
CREATE TABLE DEPT_SEQUENCE
AS SELECT * FROM DEPT WHERE 1 <> 1;

-- 시퀀스 생성하기
DROP SEQUENCE SEQ_DEPT_SEQUENCE;
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
	INCREMENT BY 10
	START WITH 10
	MAXVALUE 90
	MINVALUE 0
	NOCYCLE
	CACHE 2;
	
SELECT * FROM USER_SEQUENCE;

-- 시퀀스에 생성한 순번을 사용한 INSERT문 실행하기
INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'EATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE;

-- 가장 마지막으로 생성된 시퀀스 확인하기

SELECT SEQ_DEPT_SEQUENCE.CURRVAL
FROM DUAL;

--시퀀스 옵션 수정하기
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
	INCREMENT BY 3
	MAXVALUE 99
	CYCLE;
	
SELECT * FROM DEPT_SEQUENCE;